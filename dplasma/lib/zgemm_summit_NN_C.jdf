extern "C" %{
/*
 * Copyright (c) 2017-2017 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 *
 * @precisions normal z -> s d c
 * $COPYRIGHT
 *
 */

#include <math.h>

#include "dplasma/lib/dplasmajdf.h"
#include "dplasma/lib/dplasmaaux.h"
#include "dplasma_bcast.h"
#include "parsec/data_dist/matrix/two_dim_rectangle_cyclic.h"
#include "flops.h"

#if defined(PARSEC_HAVE_CUDA)
#include <cublas.h>
#endif  /* defined(PARSEC_HAVE_CUDA) */

%}

/* Keep this first, as in all jdf in this directory, to
 * enable switching between SUMMA implementations.
 * This is the JDF-like CRTP ;)
 */
summa_type [ type = int ]

transA     [ type = int ]
transB     [ type = int ]
alpha      [ type = parsec_complex64_t ]

/*
 * A is MT x KT
 * B is KT x NT
 * C is MT x NT
 */
descA      [ type = "const parsec_tiled_matrix_dc_t *" ]
descB      [ type = "const parsec_tiled_matrix_dc_t *" ]
descC      [ type = "parsec_tiled_matrix_dc_t *"       ]
TrivDist   [ type = "parsec_data_collection_t *"       ]

/*
 * The process grid is tP x tQ
 * A compute block is tB.tP x tC.tQ += tB.tP x tD.tP * tD.tP x tC.tQ
 */
tB         [ type = int ]
tC         [ type = int ]
tD         [ type = int ]
tP         [ type = int ]
tQ         [ type = int ]

nb_cuda_devices   [ type = "int"   ]
cuda_device_index [ type = "int *" ]

xMax       [ type = int default = "-1" hidden=on ]
yMax       [ type = int default = "-1" hidden=on ]
zMax       [ type = int default = "-1" hidden=on ]

/*********************************************************
 *                           READ_A                      *
 * A is broadcast to all target GEMMs from the beginning *
 *********************************************************/
READ_A(m, k)
  m = 0 .. descA->mt-1
  k = 0 .. descA->nt-1

:descA(m, k)

READ A <- descA(m, k)
       -> A GEMM(m, 0 .. descC->nt-1, k)

BODY
 /* Nothing */
END

/*********************************************************
 *                         READ_B                        *
 * B is broadcast to all target GEMMs from the beginning *
 *    This code assumes that B << A ~ C, and that this   *
 *        broadcast is in fact a local operation         *
 *********************************************************/
READ_B(k, n)
  k = 0 .. descB->mt-1
  n = 0 .. descB->nt-1

: descB(k, n)

READ B <- descB(k, n)
       -> B GEMM(0 .. descC->mt-1, n, k)

BODY
  /* Nothing */
END

/**************************************************
 *                       READ_C                   *
 **************************************************/

READ_C(m, n)
  m = 0 .. descC->mt-1
  n = 0 .. descC->nt-1
  r = %{ return descC->super.rank_of((parsec_data_collection_t *)descC, m, n); %}
  u = r / tQ
  v = r % tQ

: descC(m, n)

READ C <- descC(m, n)
       -> C GEMM(m, n, 0)

CTL Z <- Z LOCAL_BARRIER( m/(tB*tP), n/(tC*tQ), 0, u, v )

BODY
  if( nb_cuda_devices > 0 ) {
      int g = (n / tQ) % nb_cuda_devices;
      parsec_advise_data_on_device( _f_C->original,
                                    cuda_device_index[g],
                                    PARSEC_DEV_DATA_ADVICE_PREFERRED_DEVICE );
  }
END

/*********************************************************
 *                      LOCAL_BARRIER                    *
 *      This is the task that controls the progress      *
 *********************************************************/
LOCAL_BARRIER(x, y, z, u, v)
  x = 0 .. xMax
  y = 0 .. yMax
  z = 0 .. zMax
  u = 0 .. tP - 1
  v = 0 .. tQ - 1

  zp = %{ return z != 0 ? z-1 : zMax; %}
  xp = %{ if(z == 0) { if(x == 0) return xMax; else return x-1; } else return x; %}
  yp = %{ if(z == 0) { if(x == 0) { if(y == 0) return -1; else return y-1; } else return y; } else return y; %}

  imax = %{ int xb1 = tB - 1; int xb2 = (descC->mt - 1 - tB*tP*x - u)/tP; return xb1 < xb2 ? xb1 : xb2; %}
  jmax = %{ int yb1 = tC - 1; int yb2 = (descC->nt - 1 - tC*tQ*y - v)/tQ; return yb1 < yb2 ? yb1 : yb2; %}
  ipmax = %{ int xb1 = tB - 1;
             int xb2 = (descC->mt - 1 - tB*tP*xp - u)/tP;
             return xb1 < xb2 ? xb1 : xb2; %}
  jpmax = %{ int yb1 = tC - 1;
             int yb2 = (descC->nt - 1 - tC*tQ*yp - v)/tQ;
             return yb1 < yb2 ? yb1 : yb2; %}
  kpmax = %{ if(z == 0) return descB->mt -1; else return z*tD-1; %}

: descB(u, v)

CTL Z -> (z == 0) ?                        [ i = 0 .. imax,  j = 0 .. jmax ]  Z READ_C(tB*tP*x + i*tP + u, tQ*tC*y + j*tQ + v)
      -> (z != 0) ?                        [ i = 0 .. imax,  j = 0 .. jmax ]  Z GEMM(  tB*tP*x + i*tP + u, tQ*tC*y + j*tQ + v, z*tD)
      <- (z != 0) | (x != 0) | (y != 0) ?  [ i = 0 .. ipmax, j = 0 .. jpmax ] Z GEMM(  tB*tP*xp + i*tP + u, tQ*tC*yp + j*tQ + v, kpmax)

BODY
#if 0
printf("LOCAL_BARRIER(%d, %d, %d, %d, %d): 0 <= i <= %d, 0 <= j <= %d, 0 <= iprev <= %d, 0 <= jprev <= %d, kpmax = %d;\n",
           x, y, z, u, v, imax, jmax, ipmax, jpmax, kpmax);
#endif
  /* nothing */
END

/**************************************************
 *                       GEMM                     *
 **************************************************/

GEMM(m, n, k)
  m = 0 .. descC->mt-1
  n = 0 .. descC->nt-1
  k = 0 .. descB->mt-1
  r = %{ return descC->super.rank_of((parsec_data_collection_t *)descC, m, n); %}
  u = r / tQ
  v = r % tQ

  x = m/(tB*tP)
  y = n/(tC*tQ)
  z = k/tD

: descC(m, n)

READ A <- A READ_A(m, k)
READ B <- B READ_B(k, n)
RW   C <- k == 0 ? C READ_C(m, n)
                 : C GEMM(m, n, k-1 )
       -> k + 1 == descB->mt ? descC(m, n)
                             : C GEMM(m, n, k+1)

CTL Z <- ( k > 0 ) & ((k % tD) == 0) ? Z LOCAL_BARRIER(x, y, z, u, v)
      ->                       (k == (z+1)*tD-1)  & (z <  zMax)                            ? Z LOCAL_BARRIER(x, y, z+1, u, v)
      -> ((k == descB->mt-1) | (k == (z+1)*tD-1)) & (z == zMax) & (x <  xMax)              ? Z LOCAL_BARRIER(x+1, y, 0, u, v)
      -> ((k == descB->mt-1) | (k == (z+1)*tD-1)) & (z == zMax) & (x == xMax) & (y < yMax) ? Z LOCAL_BARRIER(0, y+1, 0, u, v)
    
BODY [type=CUDA
      dyld=cublasZgemm dyldtype=cublas_zgemm_t
      weight=(descA->nt-k)]
{
#if defined(PRECISION_z) || defined(PRECISION_c)
    cuDoubleComplex lalpha = make_cuDoubleComplex(creal(alpha), cimag(alpha));
    cuDoubleComplex lbeta  = (k == 0) ? make_cuDoubleComplex(0.0, 0.0) : make_cuDoubleComplex(1.0, 0.0);
#else
    double lalpha = alpha;
    double lbeta  = (k==0) ? 0.0:1.0;
#endif
    int cAmb = descA->mb;
    int cAnb = descA->nb;
    int cBmb = descB->mb;
    int cBnb = descB->nb;
    int cCmb = cAmb;
    int cCnb = cBnb;

    int tempmm = cCmb;
    int tempnn = cCnb;
    int tempkk = cAnb;
    int ldam = cAmb;
    int ldbk = cBmb;
    int ldcm = cCmb;

#if defined(PARSEC_DEBUG_NOISIER)
    /* fprintf(stdout, */
    /*         "CUDA: gemm( %d, %d, %d ) > A(%d,%d) * B(%d,%d) C(%d,%d)\n", */
    /*         m, n, k, cAmb, cAnb, cBmb, cBnb, cCmb, cCnb); */
#endif

    cublasStatus_t status;
    cublasSetKernelStream( parsec_body.stream );
    parsec_body.dyld_fn( lapack_const(transA), lapack_const(transB),
             tempmm, tempnn, tempkk,
             lalpha, (cuDoubleComplex*)A, ldam,
                     (cuDoubleComplex*)B, ldbk,
             lbeta,  (cuDoubleComplex*)C, ldcm );
    status = cublasGetError();
    PARSEC_CUDA_CHECK_ERROR( "cublasZgemm ", status,
                            {return -1;} );

    /* Quick and dirty emulation of the next GEMM */
    if( k == descC->mt -1 ) {
        __parsec_zgemm_summit_NN_C_GEMM_task_t next_gemm;
        memcpy(&next_gemm, this_task, sizeof(__parsec_zgemm_summit_NN_C_GEMM_task_t));
        next_gemm.locals.k.value = descC->mt -1;
        assert( PARSEC_DEV_CUDA == next_gemm.task_class->incarnations[this_task->chore_id].type );
        if(NULL != next_gemm.task_class->incarnations[this_task->chore_id].evaluate) {
            if( next_gemm.task_class->incarnations[this_task->chore_id].evaluate((parsec_task_t*)&next_gemm) ==
                PARSEC_HOOK_RETURN_NEXT ) {
                    /* The next GEMM wants to run on the CPUs... */
                    gpu_task->pushout |= (1 << 0);
            }
        }
    }
    
}
END

BODY
{
    parsec_complex64_t lbeta = (k==0) ? (parsec_complex64_t)0.0 : (parsec_complex64_t)1.0;

    int cAmb = descA->mb;
    int cAnb = descA->nb;
    int cBmb = descB->mb;
    int cBnb = descB->nb;
    int cCmb = cAmb;
    int cCnb = cBnb;

    int tempmm = cCmb;
    int tempnn = cCnb;
    int tempkk = cAnb;
    int ldam = cAmb;
    int ldbk = cBmb;
    int ldcm = cCmb;

#if 0
printf("%s GEMM(%d, %d, %d): x = %d, y = %d, z = %d, r = %d, u = %d, v = %d, firstk = %d\n",
    	   (k + tP >= descB->mt) || (k == z*tD) ? "***" : "   ",
           m, n, k, x, y, z, r, u, v, z*tD);
#endif

#if !defined(PARSEC_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#endif  /* !defined(PARSEC_DRY_RUN) */

    printlog("gemm( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );
}
END
