/*
 * Copyright (c) 2009-2016 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 */

#ifndef _DAGUE_scheduling_h
#define _DAGUE_scheduling_h

#include "dague_internal.h"

BEGIN_C_DECLS

/**
 * Mark a execution context as being ready to be scheduled, i.e. all
 * input dependencies are resolved. The execution context can be
 * executed immediately or delayed until resources become available.
 *
 * @param [IN] The execution context to be executed. This include
 *             calling the attached hook (if any) as well as marking
 *             all dependencies as completed.
 *
 * @return  0 If the execution was succesful and all output dependencies
 *            has been correctly marked.
 * @return -1 If something went wrong.
 */
int __dague_schedule( dague_execution_unit_t*, dague_execution_context_t*);

int __dague_context_wait(dague_execution_unit_t* eu_context);

/**
 * Execute the body of the task associated to the context.
 */
int __dague_execute( dague_execution_unit_t*, dague_execution_context_t*);
/**
 * Signal the termination of the execution context to all dependencies of
 * its dependencies.
 *
 * @param [IN]  The execution context of the finished task.
 * @param [IN]  The task to be completed
 *
 * @return 0    If the dependencies have successfully been signaled.
 * @return -1   If something went wrong.
 */
int __dague_complete_execution( dague_execution_unit_t *eu_context,
                              dague_execution_context_t *exec_context );

/**
 * Signal the handle that a certain number of runtime bound activities have been
 * completed. Such activities includes network communications, other local data
 * transfers, and more generally any activity generated by the runtime itself
 * that is related to the handle. In addition, we assume that one extra activity
 * is to the capability of the upper level to generate tasks, activity that has
 * it's own counter, handled via dague_handle_update_nbtask. Thus, once the
 * upper level knows no local tasks will be further generate it is it's
 * responsability to update the runtime counter accordingly.
 *
 * @return 0 if the handle has not been completed.
 * @return 1 if the handle has been completed and it has been marked for release.
 */
int dague_handle_update_runtime_nbtask(dague_handle_t *dague_handle, int32_t nb_tasks);

/**
 * When changing the number of local tasks, see if we need to call the
 * DAG complete_cb callback, and/or if we need to update the number of
 * active objects.
 *
 * remaining is the number of local tasks available, after updating it
 * using the appropriate atomic operation
 */
int dague_check_complete_cb(dague_handle_t *dague_handle, dague_context_t *context, int remaining);

/**
 * Loads the scheduler as selected using the MCA logic
 * You better not call this while computations are in progress,
 *  i.e. it should be safe to call this when the main thread is
 *  not yet inside dague_progress, but *before* any call to
 *  dague_progress...
 *
 *  @RETURN 1 if the new scheduler was succesfully installed
 *          0 if it failed. In this case, the previous scheduler
 *            is kept.
 */
int dague_set_scheduler( dague_context_t *dague );

/**
 *  Removes the current scheduler (cleanup)
 */
void dague_remove_scheduler( dague_context_t *dague );

struct dague_sched_module_s;
extern struct dague_sched_module_s *current_scheduler;

END_C_DECLS

#endif  /* _DAGUE_scheduling_h */
