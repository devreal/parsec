extern "C" %{
/*
 * Copyright (c) 2010-2016 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 *
 * @precisions normal z -> s d c
 * $COPYRIGHT
 *
 */
#include "summa/lib/dplasmajdf.h"
#include "summa/lib/dplasmaaux.h"
#include "irregular_tiled_matrix.h"
#include <math.h>

#if defined(DAGUE_HAVE_CUDA)
#include <cublas.h>
#endif  /* defined(DAGUE_HAVE_CUDA) */

%}

/*
 * Globals
 */
transA  [type = int]
transB  [type = int]

alpha   [type = dague_complex64_t]

dataA   [type = "dague_ddesc_t *"]
descA   [type = "irregular_tiled_matrix_desc_t" hidden = on default = "*((irregular_tiled_matrix_desc_t*)dataA)"]
dataB   [type = "dague_ddesc_t *"]
descB   [type = "irregular_tiled_matrix_desc_t" hidden = on default = "*((irregular_tiled_matrix_desc_t*)dataB)"]
dataC   [type = "dague_ddesc_t *"]
descC   [type = "irregular_tiled_matrix_desc_t" hidden = on default = "*((irregular_tiled_matrix_desc_t*)dataC)"]
Cdist   [type = "dague_ddesc_t *"]

P       [type = "int" hidden=on default="descC.grid.rows"]
Q       [type = "int" hidden=on default="descC.grid.cols"]
/* Look ahead on both dimensions */
lookP   [type = "int" hidden=on default="summa_aux_getSUMMALookahead(&descC)"]
lookQ   [type = "int" hidden=on default="summa_aux_getSUMMALookahead(&descC)"]
createC [type = "int"]

/**************************************************
 *                       READ_A                   *
 **************************************************/
READ_A(k, m)  [profile = off]

k = 0 .. descA.mt-1
m = 0 .. descA.nt-1

: dataA(k, m)

READ A <- dataA(k, m)
       -> A RING_A(k, m, k%Q)
BODY
{
    printlog("rank %u <- A(%d,%d)\n", __dague_handle->super.dataA->myrank, k, m);
}
END

RING_A(k, m, q)  [profile = off]

k = 0 .. descA.mt-1
m = 0 .. descA.nt-1
q = 0 .. Q-1
prevq = (q-1+Q)%Q
nextq = (q+1)%Q

: Cdist(m, q)

READ A <- (k%Q == q) ? A READ_A(k, m) : A RING_A(k, m, prevq)
       -> A SUMMA(m, q .. descC.nt-1 .. Q, k)
       -> (nextq != (k%Q)) ? A RING_A(k, m, nextq)

CTL ctla <- (k >= lookQ) ? ctla SUMMA(m, q .. descC.nt-1 .. Q, k-lookQ)

BODY
{
    printlog("rank %u <- A(%d,%d)\n", __dague_handle->super.dataA->myrank, k, m);
}
END

/**************************************************
 *                       READ_B                   *
 **************************************************/
READ_B(k, n) [profile = off]

k = 0 .. descB.mt-1
n = 0 .. descB.nt-1

: dataB(k, n)

READ B <- dataB(k, n)
       -> B RING_B(k, n, k%P)
BODY
{
     printlog("rank %u <- B(%d,%d)\n", __dague_handle->super.dataB->myrank, k, n);
}
END

RING_B(k, n, p)  [profile = off]

k = 0 .. descB.mt-1
n = 0 .. descB.nt-1
p = 0 .. P-1
prevp = (p-1+P)%P
nextp = (p+1)%P

: Cdist(p, n)

READ B <- (k%P == p) ? B READ_B(k, n) : B RING_B(k, n, prevp)
       -> B SUMMA(p .. descC.mt-1 .. P, n, k)
       -> (nextp != (k%P)) ? B RING_B(k, n, nextp)

CTL ctlb <- (k >= lookP) ? ctlb SUMMA(p .. descC.mt-1 .. P, n, k-lookP)

BODY
{
     printlog("rank %u <- B(%d,%d)\n", __dague_handle->super.dataB->myrank, k, n);
}
END

/**************************************************
 *                       SUMMA                     *
 **************************************************/
SUMMA(m, n, k)

// Execution space
m = 0 .. descC.mt-1
n = 0 .. descC.nt-1
k = 0 .. descA.mt-1

// Parallel partitioning
: dataC(m, n)

// Parameters
READ A <- A RING_A(k, m, n%Q)
READ B <- B RING_B(k, n, m%P)
RW   C <- ((k == 0) & (createC == 1)) ? NEW
       <- ((k == 0) & (createC == 0)) ? dataC(m,n)
       <- (k>0)                       ? C SUMMA(m,n,k-1)
       -> (k == (descA.mt-1))         ? dataC(m, n) : C SUMMA( m, n, k+1 )

CTL ctla -> (k < (descA.mt-lookQ)) ? ctla RING_A(k+lookQ, m, n%Q)
CTL ctlb -> (k < (descA.mt-lookP)) ? ctlb RING_B(k+lookP, n, m%P)

BODY [type=CUDA
      dyld=cublasZgemm dyldtype=cublas_zgemm_t
      weight=(descA.mt-k)]
{
#if defined(PRECISION_z) || defined(PRECISION_c)
    cuDoubleComplex lalpha = make_cuDoubleComplex(creal(alpha), cimag(alpha));
    cuDoubleComplex lbeta  = (k == 0) ? make_cuDoubleComplex(0.0, 0.0) : make_cuDoubleComplex(1.0, 0.0);
#else
    double lalpha = alpha;
    double lbeta  = (k==0) ? 0.0:1.0;
#endif
    irregular_tile_data_copy_t *cA = (irregular_tile_data_copy_t*)gA;
    irregular_tile_data_copy_t *cB = (irregular_tile_data_copy_t*)gB;
    irregular_tile_data_copy_t *cC = (irregular_tile_data_copy_t*)gC;
    int tempmm = cC->mb;
    int tempnn = cC->nb;
    int tempkk = cA->mb;
    int ldak = cA->nb;
    int ldbk = cB->mb;
    int ldcm = cC->mb;

    cublasStatus_t status;
    cublasSetKernelStream( dague_body.stream );
    dague_body.dyld_fn( lapack_const(transA), lapack_const(transB),
             tempmm, tempnn, tempkk,
             lalpha, (cuDoubleComplex*)A, ldak,
                     (cuDoubleComplex*)B, ldbk,
             lbeta,  (cuDoubleComplex*)C, ldcm );
    status = cublasGetError();
    DAGUE_CUDA_CHECK_ERROR( "cublasZsumma ", status,
                            {return -1;} );
}
END

BODY
{
    dague_complex64_t lbeta = (k==0) ? (dague_complex64_t)0.0 : (dague_complex64_t)1.0;
    irregular_tile_data_copy_t *cA = (irregular_tile_data_copy_t*)gA;
    irregular_tile_data_copy_t *cB = (irregular_tile_data_copy_t*)gB;
    irregular_tile_data_copy_t *cC = (irregular_tile_data_copy_t*)gC;
    int tempmm = cC->mb;
    int tempnn = cC->nb;
    int tempkk = cA->mb;
    int ldak = cA->nb;
    int ldbk = cB->mb;
    int ldcm = cC->mb;

    fprintf(stdout, "summa( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), k, m, ldak,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm);
#if !defined(DAGUE_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(k, m)*/, ldak,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#endif  /* !defined(DAGUE_DRY_RUN) */

    printlog("summa( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), k, m, ldak,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm);
}
END
