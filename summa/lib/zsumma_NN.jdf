extern "C" %{
/*
 * Copyright (c) 2010-2017 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 *
 * @precisions normal z -> s d c
 * $COPYRIGHT
 *
 */
#include "summa/lib/dplasmajdf.h"
#include "summa/lib/dplasmaaux.h"
#include "data_dist/matrix/two_dim_rectangle_cyclic.h"
#include "summa_z.h"
#include "flops.h"
#include <math.h>

#if defined(PARSEC_HAVE_CUDA)
#include <cublas.h>
#endif  /* defined(PARSEC_HAVE_CUDA) */

#if defined(PARSEC_HAVE_RECURSIVE)
#include "irregular_subtile.h"
#endif

%}

/*
 * Globals
 */

/* Keep this first, as in all jdf in this directory, to
 * enable switching between SUMMA implementations.
 * This is the JDF-like CRTP ;)
 */
summa_type [type = int]

transA  [type = int]
transB  [type = int]

alpha   [type = parsec_complex64_t]

descA   [type = "const irregular_tiled_matrix_desc_t *"]
descB   [type = "const irregular_tiled_matrix_desc_t *"]
descC   [type = "irregular_tiled_matrix_desc_t *"]
Cdist   [type = "const two_dim_block_cyclic_t *"]

P       [type = "int" hidden=on default="descC->grid.rows"]
Q       [type = "int" hidden=on default="descC->grid.cols"]
/* Look ahead on both dimensions */
lookP   [type = "int" hidden=on default="summa_aux_getSUMMALookahead(descC)"]
lookQ   [type = "int" hidden=on default="summa_aux_getSUMMALookahead(descC)"]
createC [type = "int"]

bigtile [type = "int" hidden=on default="-1"]
opttile [type = "int" hidden=on default="descA->max_mb"]

/**************************************************
 *                       READ_A                   *
 **************************************************/
READ_A(m, k)  [profile = off]

m = 0 .. descA->mt-1
k = 0 .. descA->nt-1

: descA(m, k)

READ A <- descA(m, k)
       -> A RING_A(m, k, k%Q) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]
BODY
{
    printlog("rank %u <- A(%d,%d)\n", ((parsec_ddesc_t*)descA)->myrank, m, k);
}
END

RING_A(m, k, q)  [profile = off]

m = 0 .. descA->mt-1
k = 0 .. descA->nt-1
q = 0 .. Q-1
prevq = (q-1+Q)%Q
nextq = (q+1)%Q

: Cdist(m, q)

READ A <- (k%Q == q) ? A READ_A(m, k) : A RING_A(m, k, prevq) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]
    -> A SUMMA(m, q .. descC->nt-1 .. Q, k) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]
       -> (nextq != (k%Q)) ? A RING_A(m, k, nextq) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]

CTL ctla <- (k >= lookQ) ? ctla SUMMA(m, q .. descC->nt-1 .. Q, k-lookQ)

BODY
{
    printlog("rank %u <- A(%d,%d)\n", ((parsec_ddesc_t*)descA)->myrank, m, k);
}
END

/**************************************************
 *                       READ_B                   *
 **************************************************/
READ_B(k, n) [profile = off]

k = 0 .. descB->mt-1
n = 0 .. descB->nt-1

: descB(k, n)

READ B <- descB(k, n)
       -> B RING_B(k, n, k%P) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
BODY
{
     printlog("rank %u <- B(%d,%d)\n", ((parsec_ddesc_t*)descB)->myrank, k, n);
}
END

RING_B(k, n, p)  [profile = off]

k = 0 .. descB->mt-1
n = 0 .. descB->nt-1
p = 0 .. P-1
prevp = (p-1+P)%P
nextp = (p+1)%P

: Cdist(p, n)

    READ B <- ((k%P) == p) ? B READ_B(k, n) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
    <- ((k%P) != p) ? B RING_B(k, n, prevp) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
       -> B SUMMA(p .. descC->mt-1 .. P, n, k) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
       -> (nextp != (k%P)) ? B RING_B(k, n, nextp) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]

CTL ctlb <- (k >= lookP) ? ctlb SUMMA(p .. descC->mt-1 .. P, n, k-lookP)

BODY
{
    printlog("rank %u <- B(%d,%d)\n", ((parsec_ddesc_t*)descB)->myrank, k, n);
}
END

/**************************************************
 *                       SUMMA                     *
 **************************************************/
SUMMA(m, n, k)

// Execution space
m = 0 .. descC->mt-1
n = 0 .. descC->nt-1
k = 0 .. descA->nt-1
iAm = %{ return descA->Mtiling[m]; %}
iBk = %{ return descB->Mtiling[k]; %}
iCn = %{ return descB->Ntiling[n]; %}

// Parallel partitioning
: descC(m, n)

// Parameters
READ A <- A RING_A(m, k, n%Q) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]
READ B <- B RING_B(k, n, m%P) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
RW   C <- ((k == 0) & (createC == 1)) ? NEW [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
       <- ((k == 0) & (createC == 0)) ? descC(m,n) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
       <- (k > 0)                     ? C SUMMA(m,n,k-1) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
       -> (k == (descA->nt-1))        ? descC(m, n) : C SUMMA( m, n, k+1 ) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]

CTL ctla -> (k < (descA->nt-lookQ)) ? ctla RING_A(m, k+lookQ, n%Q)
CTL ctlb -> (k < (descA->nt-lookP)) ? ctlb RING_B(k+lookP, n, m%P)

BODY [type=CUDA
      dyld=cublasZgemm dyldtype=cublas_zgemm_t
      weight=(descA->nt-k)]
{
    /* fprintf(stdout, "CUDA BODY for task (%d;%d;%d)\n", m,n,k); */
    /* return PARSEC_HOOK_RETURN_NEXT; */
#if defined(PRECISION_z) || defined(PRECISION_c)
    cuDoubleComplex lalpha = make_cuDoubleComplex(creal(alpha), cimag(alpha));
    cuDoubleComplex lbeta  = (k == 0) ? make_cuDoubleComplex(0.0, 0.0) : make_cuDoubleComplex(1.0, 0.0);
#else
    double lalpha = alpha;
    double lbeta  = (k==0) ? 0.0:1.0;
#endif
    int tempmm = SUMMA_N_ROWS(descA, m);
    int tempnn = SUMMA_N_COLS(descB, n);
    int tempkk = SUMMA_N_ROWS(descB, k);
    int ldam = SUMMA_N_BLKLDD(descA, m);
    int ldbk = SUMMA_N_BLKLDD(descB, k);
    int ldcm = SUMMA_N_BLKLDD(descC, m);

    double flops = FLOPS_ZSUMMA((double)tempmm,(double)tempnn,(double)tempkk);
    double miniflops = FLOPS_ZSUMMA(400., 400., 400.);
    /* If we think the GEMM is too small, we fall back to the next hook, should be CPU */
    /* Is it safe, can it be stuck in an infinite loop? */
    if (flops < miniflops) {
        /* fprintf(stdout, "  > SENDING TO RECURSIVE BODY: Task (%d;%d;%d)\n", m, n, k); */
        return PARSEC_HOOK_RETURN_NEXT;
    }

#if defined(PARSEC_DEBUG_NOISIER)
    /* fprintf(stdout, */
    /*         "CUDA: summa( %d, %d, %d ) > A(%d,%d) * B(%d,%d) C(%d,%d)\n", */
    /*         m, n, k, cAmb, cAnb, cBmb, cBnb, cCmb, cCnb); */
#endif

    cublasStatus_t status;
    cublasSetKernelStream( parsec_body.stream );
    parsec_body.dyld_fn( lapack_const(transA), lapack_const(transB),
             tempmm, tempnn, tempkk,
             lalpha, (cuDoubleComplex*)A, ldam,
                     (cuDoubleComplex*)B, ldbk,
             lbeta,  (cuDoubleComplex*)C, ldcm );
    status = cublasGetError();
    PARSEC_CUDA_CHECK_ERROR( "cublasZsumma ", status,
                            {return -1;} );
}
END

BODY [type=RECURSIVE]
{
    /* fprintf(stdout, "  > RECURSIVE BODY for task (%d;%d;%d)\n",m,n,k); */
    return PARSEC_HOOK_RETURN_NEXT;
    parsec_complex64_t lbeta = (k==0) ? (parsec_complex64_t)0.0 : (parsec_complex64_t)1.0;

    int tempmm = SUMMA_N_ROWS(descA, m);
    int tempnn = SUMMA_N_COLS(descB, n);
    int tempkk = SUMMA_N_ROWS(descB, k);
    int ldam = SUMMA_N_BLKLDD(descA, m);
    int ldbk = SUMMA_N_BLKLDD(descB, k);
    int ldcm = SUMMA_N_BLKLDD(descC, m);
    (void)ldam;
    (void)ldbk;
    (void)ldcm;

#if defined(PARSEC_HAVE_RECURSIVE)
    (void)lbeta;
    double flops = FLOPS_ZSUMMA((double)tempmm,(double)tempnn,(double)tempkk);
    double optiflops = FLOPS_ZSUMMA((double)opttile, (double)opttile, (double)opttile);
    int factor = flops/optiflops;

    int mtile = 1, ntile = 1, ktile = 1;
    while(factor >= 2) {
        factor = factor >> 1;
        mtile = mtile << 1;
        if (factor >= 2) {
            factor = factor >> 1;
            ntile = ntile << 1;
        }
    }

    if (mtile > 1 || ntile > 1 || ktile > 1) {
        /* fprintf(stdout, "    > RECURSIVE CUTTING for T (%d;%d;%d) in %d/%d/%d\n", */
        /*         m,n,k,mtile, ntile, ktile); */
        irregular_subtile_desc_t *small_descA;
        irregular_subtile_desc_t *small_descB;
        irregular_subtile_desc_t *small_descC;

        parsec_zsumma_NN_handle_t *parsec_zsumma;
        small_descA = irregular_subtile_desc_create(descA, m, k, mtile, ktile);
        small_descB = irregular_subtile_desc_create(descB, k, n, ktile, ntile);
        small_descC = irregular_subtile_desc_create(descC, m, n, mtile, ntile);

        /* parsec_object */
        parsec_zsumma = parsec_zsumma_NN_new(SUMMA_NN, PlasmaNoTrans, PlasmaNoTrans, alpha,
                                             (const irregular_tiled_matrix_desc_t*) small_descA,
                                             (const irregular_tiled_matrix_desc_t*) small_descB,
                                             (irregular_tiled_matrix_desc_t*) small_descC,
                                             recursive_fake_Cdist(Cdist), 0 /*createC*/);

        /* Let's skip CUDA and recursive for this handle and directly execute it on CPU */
        parsec_devices_handle_restrict((parsec_handle_t*)parsec_zsumma, PARSEC_DEV_CPU);

        /* recursive call */
        parsec_recursivecall(context, (parsec_execution_context_t*)this_task,
                             (parsec_handle_t*)parsec_zsumma, summa_zsumma_recursive_Destruct,
                             summa_recursivecall_callback,
                             3, small_descA, small_descB, small_descC);

        return PARSEC_HOOK_RETURN_ASYNC;
    }
    else {
        /* fprintf(stdout, "  > SENDING TO CPU BODY: Task (%d;%d;%d)\n", m, n, k); */
        return PARSEC_HOOK_RETURN_NEXT;
    }
#else
#  if !defined(PARSEC_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#  endif  /* !defined(PARSEC_DRY_RUN) */

    printlog("summa( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );
#endif /* PARSEC_HAVE_RECURSIVE */
}
END

BODY
{
    parsec_complex64_t lbeta = (k==0) ? (parsec_complex64_t)0.0 : (parsec_complex64_t)1.0;
    int tempmm = SUMMA_N_ROWS(descA, m);
    int tempnn = SUMMA_N_COLS(descB, n);
    int tempkk = SUMMA_N_ROWS(descB, k); 
    int ldam = SUMMA_N_BLKLDD(descA, m);
    int ldcm = SUMMA_N_BLKLDD(descC, m);
    int ldbk = SUMMA_N_BLKLDD(descB, k);

    fprintf(stdout, "summa(%d;%d;%d) (%d;%d)x(%d;%d)=(%d;%d), ldA=%d, ldB=%d, ldC=%d, A(%d;%d), B(%d;%d), C(%d;%d)\n",
            m, n, k, tempmm, tempkk, tempkk, tempnn, tempmm, tempnn,
            ldam, ldbk, ldcm, descA->Mtiling[m], descA->Ntiling[k], descB->Mtiling[k], descB->Ntiling[n], descC->Mtiling[m], descC->Ntiling[n]);

#if !defined(PARSEC_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#endif  /* !defined(PARSEC_DRY_RUN) */

    printlog("summa( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );

    fprintf(stdout, "****************************************************************\n\n");
    
}
END
