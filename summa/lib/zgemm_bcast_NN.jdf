extern "C" %{
/*
 * Copyright (c) 2017-2017 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 *
 * @precisions normal z -> s d c
 * $COPYRIGHT
 *
 */
#include "summa/lib/dplasmajdf.h"
#include "summa/lib/dplasmaaux.h"
#include "data_dist/matrix/two_dim_rectangle_cyclic.h"
#include "summa_z.h"
#include "flops.h"
	
#include <math.h>

#if defined(PARSEC_HAVE_CUDA)
#include <cublas.h>
#endif  /* defined(PARSEC_HAVE_CUDA) */

#if defined(PARSEC_HAVE_RECURSIVE)
#include "irregular_subtile.h"
#endif

int first_gemm(int m, int n, gemm_plan_t *plan);
int last_gemm(int m, int n, gemm_plan_t *plan);
int next_gemm(int m, int n, gemm_plan_t *plan, int k);
int prev_gemm(int m, int n, gemm_plan_t *plan, int k);

%}

transA [ type = int ]
transB [ type = int ]
alpha  [ type = parsec_complex64_t ]

descA    [ type = "const irregular_tiled_matrix_desc_t *" ]
descB    [ type = "const irregular_tiled_matrix_desc_t *" ]
descC    [ type = "irregular_tiled_matrix_desc_t *" ]
CompDist [ type = "parsec_ddesc_t *" ]

plan     [ type = "gemm_plan_t *" ]

READ_A(m, k)
  m = 0 .. descA->mt-1
  k = 0 .. descA->nt-1

:descA(m, k)

READ A <- descA(m, k)    [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]                  
       -> A GEMM(m, 0 .. descC->nt-1, k) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]

BODY
 /* Nothing */
END

READ_B(k, n)
  k = 0 .. descB->mt-1
  n = 0 .. descB->nt-1

: descB(k, n)

READ B <- descB(k, n)   [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
       -> B GEMM(0 .. descC->mt-1, n, k) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]

BODY
  /* Nothing */
END

ACCUMULATE_C(m, n, i)
  m = 0 .. descC->mt-1
  n = 0 .. descC->nt-1
  max = %{ return gemm_plan_max_red_index(plan, m, n); %}
  i = 0 .. max
  k = %{ return gemm_plan_k_of_red_index(plan, m, n, i); %}

: descC(m, n)

RW C <- i == 0 ? descC(m, n) : C ACCUMULATE_C(m, n, i-1) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
     -> i == max ? descC(m, n) : C ACCUMULATE_C(m, n, i+1) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
READ Ci <- C GEMM(m, n, k) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]

BODY
{
    int cCmb = descC->Mtiling[m];
    int cCnb = descC->Ntiling[n];

    parsec_complex64_t za = (parsec_complex64_t)1.0;
    CORE_zgeadd(PlasmaNoTrans, cCmb, cCnb, za, Ci, cCmb, za, C, cCmb);
}
END

GEMM(m, n, k)
  m = 0 .. descC->mt-1
  n = 0 .. descC->nt-1
  k = 0 .. descB->mt-1
  kprev = %{ return gemm_plan_prev(plan, m, n, k); %}
  knext = %{ return gemm_plan_next(plan, m, n, k); %}
  index = %{ return gemm_plan_red_index(plan, m, n, k); %}

: CompDist(k, n)

READ A <- A READ_A(m ,k) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descA, m, k); %} ]
READ B <- B READ_B(k, n) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descB, k, n); %} ]
RW C <- kprev == -1
          ? NEW          [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
     <- kprev != -1
          ? C GEMM(m, n, kprev ) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
     -> knext == -1
	  ? Ci ACCUMULATE_C(m, n, index)  [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]
     -> knext != -1
          ? C GEMM(m, n, knext) [ type= DEFAULT layout=parsec_datatype_double_complex_t  count= %{ return get_tile_count(descC, m, n); %} ]

BODY [type=CUDA
      dyld=cublasZgemm dyldtype=cublas_zgemm_t
      weight=(descA->nt-k)]
{
#if defined(PRECISION_z) || defined(PRECISION_c)
    cuDoubleComplex lalpha = make_cuDoubleComplex(creal(alpha), cimag(alpha));
    cuDoubleComplex lbeta  = (k == 0) ? make_cuDoubleComplex(0.0, 0.0) : make_cuDoubleComplex(1.0, 0.0);
#else
    double lalpha = alpha;
    double lbeta  = (k==0) ? 0.0:1.0;
#endif
    /* irregular_tile_data_copy_t *cA = (irregular_tile_data_copy_t*)_f_A; */
    /* irregular_tile_data_copy_t *cB = (irregular_tile_data_copy_t*)_f_B; */
    /* irregular_tile_data_copy_t *cC = (irregular_tile_data_copy_t*)_f_C; */
    /* int tempmm = cC->mb; */
    /* int tempnn = cC->nb; */
    /* int tempkk = cA->nb; */
    /* int ldam = cA->mb; */
    /* int ldbk = cB->mb; */
    /* int ldcm = cC->mb; */

    int cAmb = descA->Mtiling[m];
    int cAnb = descA->Ntiling[k];
    int cBmb = descB->Mtiling[k];
    int cBnb = descB->Ntiling[n];
    int cCmb = cAmb;
    int cCnb = cBnb;

    int tempmm = cCmb;
    int tempnn = cCnb;
    int tempkk = cAnb;
    int ldam = cAmb;
    int ldbk = cBmb;
    int ldcm = cCmb;

    /* fprintf(stdout, "CUDA: gemm( %d, %d, %d )\n" */
    /*         "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n", */
    /*         m, n, k, */
    /*         plasma_const( transA ), plasma_const( transB ), */
    /*         tempmm, tempnn, tempkk, */
    /*         lalpha, m, k, ldam, */
    /*         k, n, ldbk, */
    /*         lbeta, m, n, ldcm ); */

#if defined(PARSEC_DEBUG_NOISIER)
    /* fprintf(stdout, */
    /*         "CUDA: gemm( %d, %d, %d ) > A(%d,%d) * B(%d,%d) C(%d,%d)\n", */
    /*         m, n, k, cAmb, cAnb, cBmb, cBnb, cCmb, cCnb); */
#endif

    cublasStatus_t status;
    cublasSetKernelStream( parsec_body.stream );
    parsec_body.dyld_fn( lapack_const(transA), lapack_const(transB),
             tempmm, tempnn, tempkk,
             lalpha, (cuDoubleComplex*)A, ldam,
                     (cuDoubleComplex*)B, ldbk,
             lbeta,  (cuDoubleComplex*)C, ldcm );
    status = cublasGetError();
    PARSEC_CUDA_CHECK_ERROR( "cublasZgemm ", status,
                            {return -1;} );
}
END

BODY [type=RECURSIVE]
{
    parsec_complex64_t lbeta = (k==0) ? (parsec_complex64_t)0.0 : (parsec_complex64_t)1.0;

    int cAmb = descA->Mtiling[m];
    int cAnb = descA->Ntiling[k];
    int cBmb = descB->Mtiling[k];
    int cBnb = descB->Ntiling[n];
    int cCmb = cAmb;
    int cCnb = cBnb;

    int tempmm = cCmb;
    int tempnn = cCnb;
    int tempkk = cAnb;
    int ldam = GEMM_BLKLDD(descA, m);
    int ldbk = GEMM_BLKLDD(descB, k);
    int ldcm = GEMM_BLKLDD(descC, m);

#if defined(PARSEC_HAVE_RECURSIVE)
	double flops = FLOPS_ZGEMM((double)tempmm,(double)tempnn,(double)tempkk);
	double optiflops = FLOPS_ZGEMM((double)opttile, (double)opttile, (double)opttile);
	int factor = flops/optiflops;

	int mtile = 1, ntile = 1, ktile = 1;
	while(factor >= 2) {
		factor = factor >> 1;
		mtile = mtile << 1;
		if (factor >= 2) {
			factor = factor >> 1;
			ntile = ntile << 1;
		}
		if (factor >= 2) {
			factor = factor >> 1;
			ktile = ktile << 1;
		}
	}
  
	if (mtile > 1 || ntile > 1 || ktile > 1) {
		/* fprintf(stdout, "TRIGGERED for (%d;%d;%d): bigtile=%d <=? tiling[m]=%d, tiling[n]=%d, tiling[k]=%d\n", */
		/* 		m,n,k,bigtile, tempmm, tempnn, tempkk); */

		irregular_subtile_desc_t *small_descA;
		irregular_subtile_desc_t *small_descB;
		irregular_subtile_desc_t *small_descC;
        parsec_zgemm_NN_handle_t *parsec_zgemm;
		/* fprintf(stdout, "Subtiling A %d;%d ...", m, k); */
        small_descA = irregular_subtile_desc_create(descA, m, k, mtile, ktile);
		/* fprintf(stdout, "Subtiling B %d;%d ...", k, n); */
		small_descB = irregular_subtile_desc_create(descB, k, n, ktile, ntile);
		/* fprintf(stdout, "Subtiling C %d;%d ...", m, n); */
		small_descC = irregular_subtile_desc_create(descC, m, n, ktile, ktile);

        /* parsec_object */
        parsec_zgemm = parsec_zgemm_NN_new(PlasmaNoTrans, PlasmaNoTrans, alpha,
											 (const irregular_tiled_matrix_desc_t*) small_descA,
											 (const irregular_tiled_matrix_desc_t*) small_descB,
											 (irregular_tiled_matrix_desc_t*) small_descC,
											 recursive_fake_Cdist(Cdist), 0 /*createC*/);

        /* recursive call */
        parsec_recursivecall(context, (parsec_execution_context_t*)this_task,
                             (parsec_handle_t*)parsec_zgemm, gemm_zgemm_recursive_Destruct,
							 gemm_recursivecall_callback,
							 3, small_descA, small_descB, small_descC);

        return PARSEC_HOOK_RETURN_ASYNC;
    }
    else
        return PARSEC_HOOK_RETURN_NEXT;
#else
#  if !defined(PARSEC_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#  endif  /* !defined(PARSEC_DRY_RUN) */

    printlog("gemm( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );
#endif /* PARSEC_HAVE_RECURSIVE */
}
END

BODY
{
    parsec_complex64_t lbeta = (k==0) ? (parsec_complex64_t)0.0 : (parsec_complex64_t)1.0;

    int cAmb = descA->Mtiling[m];
    int cAnb = descA->Ntiling[k];
    int cBmb = descB->Mtiling[k];
    int cBnb = descB->Ntiling[n];
    int cCmb = cAmb;
    int cCnb = cBnb;

    int tempmm = cCmb;
    int tempnn = cCnb;
    int tempkk = cAnb;
    int ldam = cAmb;
    int ldbk = cBmb;
    int ldcm = cCmb;

#if !defined(PARSEC_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#endif  /* !defined(PARSEC_DRY_RUN) */

    printlog("gemm( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );
}
END

